# Get Your Hands Dirty on Clean Architecture

> https://learning.oreilly.com/library/view/get-your-hands/9781839211966/
>
> 스터디
>
> 2021.08.11 ~ 

## Chapter 1 - What's Wrong With Layers?

![image-20210811023057209](./img/01.png)

레이어는 견고한 아키텍처 패턴이다. 올바르게 이해한다면 웹 및 persistence 계층과 독립적인 도메인 로직를 구축할 수 있다. 원하는 경우 도메인 로직에 영향을 주지 않고 웹 또는 persistence 기술을 전환할 수 있다. 기존 기능에 영향을 주지 않고 새로운 기능을 추가할 수 있습니다.

좋은 계층 구조를 통해 우리는 변화하는 요구 사항과 외부 요인에 빠르게 적응할 수 있다.

그렇다면 레이어 아키텍처에 무슨 문제가 있을까?

계층화된 아키텍처는 너무 많은 열린 측면을 가지고 있다. 나쁜 습관이 침투하여 시간이 지남에 따라 소프트웨어를 변경하기가 점점 더 어려워진다. 아래에 이유가 있다.

### 데이터베이스 기반 설계를 촉진한다

기존의 레이어 아키텍처의 기초는 데이터베이스이다.

모든 것이 persistence 계층 위에 구축된다. 이것은 여러 가지 이유로 인해 문제가 됩다.

대부분의 경우 데이터베이스 구조가 어떻게 생겼는지 생각하고 그 위에 도메인 논리를 구현하는 것으로 넘어간다.

이것은 종속성의 자연스러운 흐름을 따르기 때문에 기존의 계층 구조에서 의미가 있다.

**그러나 비즈니스 관점에서는 전혀 의미가 없다.** 다른 작업을 수행하기 전에 도메인 로직를 설계해야 한다. 그래야만 제대로 이해했는지 알 수 있다. 그리고 올바른 도메인 로직을 구축하고 있다는 것을 알게 된 후에야 이를 중심으로 persistence 및 웹 레이어를 구축해야 한다.

![image-20210811023952346](./img/02.png)

도메인 계층에서 데이터베이스 엔터티를 사용하면 지속성 계층과 강력한 결합이 이루어진다.

일반적으로 위의 그림과 같이 persistence 계층의 일부로 ORM 엔터티가 있다. 계층은 그 아래의 계층에 액세스할 수 있으므로 도메인 계층은 해당 엔터티에 접근할 수 있다.

**이것은 persistence 계층과 도메인 계층 사이에 강력한 결합을 생성한다. 우리 서비스는 persistence 모델을 비즈니스 모델로 사용하며 도메인 논리뿐만 아니라 eager vs lazy loading, 데이터베이스 트랜잭션, 캐시 플러시 및 유사한 하우스키핑 작업도 처리해야 한다.**

**persistence 코드는 사실상 도메인 코드에 결합되어 있기 때문에 변경하기가 어렵다.** 이는 우리 아키텍처의 목표가 되어야 하는 유연하고 옵션을 열어두는 것과는 반대이다.

### 바로 가기가 쉽다(레이어 경계가 흐려진다)

기존의 계층 구조에서 유일한 전역 규칙은 특정 계층에서 동일한 계층 또는 그 아래 계층의 구성 요소에만 액세스할 수 있다는 것이다.

따라서 상위 계층의 특정 구성 요소에 액세스해야 하는 경우 해당 구성 요소를 한 계층 아래로 푸시하면 액세스할 수 있다.

![image-20210811025042161](./img/03.png)

persistence 계층의 모든 항목에 액세스할 수 있으므로 시간이 지남에 따라 뚱뚱해지는 경향이 있다.

Helper 또는 Util 요소는 특정 계층에 속하지 않으므로 최하위 계층으로 밀어 내려서 접근하다 보면 점점 뚱뚱해진다.

**이러한 현상으로 레이어 경계가 점점 흐려진다.**

### 테스트가 어려워 진다

계층화된 아키텍처 내에서 일반적인 발전은 계층을 건너뛰는 것이다. 우리는 Entity의 단일 필드만 조작하기 때문에 웹 레이어에서 직접 Persistence 레이어에 액세스하고 도메인 레이어를 귀찮게 할 필요가 없다.

그러나, **도메인 계층을 건너뛰면 코드 기반 전체에 도메인 로직이 분산되는 경향이 있다.**

![image-20210811030024911](./img/04.png)

처음 몇 번은 괜찮게 느껴지지만 자주 발생하면 두 가지 단점이 있다.

첫째, 단일 필드만 조작하는 경우에도 웹 계층에서 도메인 로직을 구현한다. 앞으로 유스케이스가 확장된다면? 우리는 웹 계층에 더 많은 도메인 로직을 추가하여 책임을 혼합하고 애플리케이션 전체에 필수적인 도메인 로직를 퍼뜨린다.

둘째, 웹 계층 테스트에서 도메인 계층뿐만 아니라 persistence 계층도 mocking해야 한다. 이것은 단위 테스트에 복잡성을 추가한다.

웹 구성요소는 시간이 지남에 따라 증가하므로 서로 다른 persistence 구성요소에 대한 의존도가 높아져 테스트의 복잡성이 가중될 수 있다. 어느 순간, 우리가 의존성을 이해하고 mocking 하는데 실제로 서비스 코드를 작성하는 것보다 더 많은 시간이 소요된다. 

### Use Case를 숨긴다

우리는 일반적으로 새 코드를 만드는 것보다 기존 코드를 변경하는 데 훨씬 더 많은 시간을 보낸다.

기능을 추가하거나 변경할 적절한 위치를 자주 찾기 때문에 아키텍처는 코드 기반을 빠르게 탐색하는 데 도움이 된다. 이와 관련하여 계층화된 아키텍처는 어떻게 유지되고 있을까?

계층화된 아키텍처에서 도메인 로직이 계층 전체에 쉽게 분산될 수 있다. 계층을 건너뛰는 접근이 많아진다. 그리고 도메인과 지속성 계층 모두에서 액세스할 수 있도록 특정 구성 요소들이 최하위 계층에 존재할 수 있다. 이것은 새로운 기능을 추가할 적절한 위치를 찾는 것을 어렵게 만든다.

![image-20210811032258680](./img/05.png)

계층 구조는 도메인 서비스의 "폭"에 대한 규칙을 부과하지 않는다. 시간이 지남에 따라 위의 그림과 같이 여러 사용 사례를 지원하는 매우 광범위한 서비스로 이어지는 경우가 많다.

광범위한 서비스는 persistence 계층에 대한 많은 종속성을 가지며 웹 계층의 많은 구성 요소가 persistence 계층에 의존한다. 이것은 서비스를 테스트하기 어렵게 만들 뿐만 아니라 우리가 작업하려는 사용 사례를 담당하는 서비스를 찾기 어렵게 만든다.

각각 단일 사용 사례를 제공하는 고도로 전문화된 좁은 도메인 서비스가 있다면 얼마나 쉬울까? UserService에서 사용자 등록 사용 사례를 검색하는 대신 RegisterUserService를 열고 작업을 시작하면 된다.

### 동시에 개발하기 어려워진다

소프트웨어 개발자로서 내 경력에서 "완료된" 소프트웨어를 본 적이 없다는 사실을 제외하고, 특정 날짜까지 완료된다는 것은 일반적으로 우리가 병렬로 작업해야 함을 의미한다.

이러한 기대를 충족하려면 아키텍처가 병렬 작업을 지원해야 합니다. 그리고 계층화된 아키텍처는 여기에서 우리에게 실제로 도움이 되지 않는다.

애플리케이션에 새로운 사용 사례를 추가한다고 상상해보자. 세 명의 개발자가 있다. 한명은 필요한 기능을 웹 레이어에 추가하고, 한명은 도메인 레이어, 한명은 persistence 레이어에 기능을 추가할 수 있다.

일반적으로 계층 구조에서는 병렬로 작업하기 힘들다. 모든 것이 persistence 레이어 위에 구축되기 때문에 persistence 레이어가 먼저 개발되어야 한다. 그런 다음 도메인 계층이 오고 마지막으로 웹 계층이 온다. 따라서 한 명의 개발자만 동시에 기능에 대해 작업할 수 있다.

개발자가 먼저 인터페이스를 정의하면 각 개발자가 실제 구현을 기다릴 필요 없이 이러한 인터페이스에 대해 작업할 수도 있다.

물론 이마저도 persistence 레이어와 도메인 로직이 결합되어있지 않은 경우(데이터베이스 중심으로 설계를 하지 않은 경우)에만 가능하다.

코드베이스에 광범위한 서비스가 있는 경우 다른 기능을 병렬로 작업하는 것이 어려울 수도 있다. 동일한 서비스가 병렬로 편집되어 병합 충돌이 발생한다.

### 유지 보수 가능한 소프트웨어를 구축하는 데 어떤 도움이 될까?

위에 언급한 주제들은 계층화된 아키텍처가 많은 것들이 잘못될 수 있음을 보여준다.  
매우 엄격한 자기 훈련이 없으면 시간이 지남에 따라 성능이 저하되고 유지 보수가 어려워지기 쉽다.  
그리고 이러한 자기 훈련은 일반적으로 관리자가 개발 팀에 대해 새로운 마감일을 정할 때마다 덜 엄격해진다.

계층화된 아키텍처의 함정을 염두에 두는 것은  
다음 번에 우리가 지름길을 택하는 것에 반대하고  
계층화된 아키텍처든 다른 아키텍처 스타일이든 대신 유지 관리 가능한 솔루션을 구축하는 데 도움이 될 것이다.

## Chapter 2 - Inverting Dependencies

### The Single Responsibility Principle

소프트웨어 개발에 종사하는 모든 사람이 SRP(Single Responsibility Principle)를 알고 있거나 적어도 안다고 가정할 수 있다. 이 원칙의 일반적인 해석은 다음과 같다. 구성 요소는 한 가지만 제대로 수행해야 하며 올바르게 수행해야 한다.

좋은 조언이긴 하지만 SRP의 실제 의도는 아니다.

SRP의 실제 정의는 다음과 같습니다.  
구성 요소에는 변경 이유가 하나만 있어야 한다.  
우리가 볼 수 있듯이, '책임'은 실제로 '한 가지만 하라'가 아니라 '변해야 할 이유'로 번역되어야 한다.

SRP의 이름을 "단일 변경 이유"로 바꿔야 할 것 같다.

구성 요소가 변경해야 할 이유가 하나뿐이라면 결국 하나만 수행하게 될 수도 있지만,  
더 중요한 것은 구성 요소가 변경해야 할 이유가 이 하나뿐이라는 것이다.

이는 아키텍처에 어떤 의미가 있을까?

구성 요소를 변경해야 하는 이유가 하나뿐이라면 다른 이유로 소프트웨어를 변경해도 이 구성 요소는 전혀 걱정하지 않아도 된다. 소프트웨어가 예상대로 작동한다는 것을 알고 있기 때문이다.

![image-20210812050611044](./img/06.png)

구성 요소의 각 종속성이 이 구성 요소를 변경할 수 있는 가능한 이유임(점멸 화살표)  
앞의 그림에서 구성요소 A는 많은 다른 구성요소(직접적 또는 일시적)에 의존하는 반면 구성요소 E는 의존성이 전혀 없다.

구성 요소 E를 변경하는 유일한 이유는 새로운 요구 사항으로 인해 E의 기능을 변경해야 하는 경우이다.  
그러나 구성 요소 A는 다른 구성 요소에 종속되기 때문에 다른 구성 요소가 변경될 때 변경해야 할 수 있다.

많은 코드베이스는 SRP 위반으로 인해 시간이 지남에 따라 변경하기가 더 어려워지고, 따라서 비용이 증가한다.  
시간이 지남에 따라 구성 요소는 점점 더 많은 변경 이유를 수집한다.  
변경해야 할 많은 이유를 수집한 후 한 구성 요소를 변경하면 다른 구성 요소가 실패할 수 있다.

### A Tale about Side Effects

다른 소프트웨어 팀에서 만든 10년 된 코드베이스를 우리 팀이 물려받은 프로젝트에 참여한 적이 있다. 클라이언트는 향후 유지 관리 및 개발을 개선하고 비용을 절감하기 위해 개발 팀을 교체하기로 결정했었다.

예상했던 대로 코드가 실제로 어떤 기능을 하는지 파악하기가 쉽지 않았고, 코드베이스의 한 영역에서 변경한 사항들은 다른 부분에서 부작용을 일으키는 경우가 많았다. 하지만 철저한 테스트, 자동화된 테스트 추가, 많은 리팩터링 등을 통해 관리했다.

코드베이스를 성공적으로 유지 및 확장한 후, 고객은 소프트웨어 사용자들에게 매우 어색한 방식으로 새로운 기능을 구현해 줄 것을 요청했다. 그래서 전체적인 변경사항이 적기 때문에 구현 비용이 훨씬 적게 드는 보다 사용자 친화적인 방식으로 수행하자고 제안했다. 그러나 매우 중요한 특정 구성 요소에서 약간의 변경이 필요했다.

클라이언트는 거절하고 더 어색하고 비싼 솔루션을 주문했다. 그 이유를 물었더니 과거 개발팀의 그 한 가지 부품 변화로 인해 항상 다른 것이 고장났기 때문에 부작용이 두렵다고 한다.

슬프게도 이것은 잘못 설계된 소프트웨어를 수정하는 데 추가 비용을 지불하도록 클라이언트를 훈련시키는 방법의 한 예시다. 운 좋게도 대부분의 클라이언트는 이 방법과 함께 하지 않을테니, 대신 좋은 소프트웨어를 빌드해 보자.

### The Dependency Inversion Principle

우리의 계층 구조에서 계층 간 종속성은 항상 아래쪽, 즉 다음 계층을 가리킨다. SRP를 높은 수준에 적용하면 상위 계층이 하위 계층보다 변경해야 할 이유가 더 많다는 것을 알 수 있다.

Persistence 계층에 대한 도메인 계층의 종속성으로 인해 persistence 계층의 각 변경은 잠재적으로 도메인 계층의 변경을 필요로 한다. 그러나 도메인 코드는 우리 애플리케이션에서 가장 중요한 코드이다. 지속성 코드에서 무언가가 변경될 때 이를 변경하고 싶지 않다.

그렇다면 이 의존성을 어떻게 없앨 수 있을까?  
DIP(Dependency Inversion Principle)가 답을 제공한다.  
우리는 코드베이스 내에서 모든 종속성의 방향을 바꿀 수 있다.  

우리는 의존성의 양쪽에서 코드를 제어할 수 있을 때만 의존성을 반전시킬 수 있다. 타사 라이브러리에 대한 종속성이 있는 경우 해당 라이브러리의 코드를 제어하지 않으므로 반전할 수 없다.

persistence 코드가 도메인 코드에 종속되도록 도메인과 persistence 코드 간의 종속성을 반전시켜 도메인 코드를 변경해야 하는 이유의 수를 줄이도록 하자.

![image-20210811023952346](./img/02.png)

도메인 계층에는 persistence 계층의 엔티티 및 리포지토리와 함께 작동하는 서비스가 있다.

![image-20210812052403296](./img/07.png)

도메인 계층으로 엔티티를 끌어올리려고 한다. 엔티티는 도메인 객체를 나타내며 도메인 코드는 엔티티의 상태 변화를 중심으로 이루어지기 때문이다.

그러나 persistence 계층의 리포지토리는 도메인 계층에 있는 엔티티에 따라 달라지기 때문에 두 계층 간에 순환 종속성을 갖게 된다. 여기가 DIP를 적용하는 곳이다. 도메인 계층에 리포지토리에 대한 인터페이스를 만들고 persistence 계층의 실제 리포지토리가 이를 구현하도록 합니다.

**도메인 계층에 인터페이스를 도입하여 지속성 계층이 도메인 계층에 종속되도록 종속성을 반전할 수 있다.**  
이 트릭을 사용하여 지속성 코드에 대한 억압적인 종속성에서 도메인 로직을 해방시켰다. 이것은 다음 섹션에서 논의할 두 가지 아키텍처 스타일의 핵심 기능입니다.

### Clean Architecture

클린 아키텍처에서 비즈니스 규칙은 설계상 테스트 가능하며 프레임워크, 데이터베이스, UI 기술 및 기타 외부 애플리케이션이나 인터페이스와 독립적이다.

도메인 코드에는 외부로 향하는 종속성이 없어야 한다. 대신 DIP의 도움으로 모든 종속성이 도메인 코드를 가리킨다.

다음 그림은 그러한 아키텍처가 추상적인 수준에서 어떻게 보일 수 있는지 보여준다.

![image-20210812053357016](./img/08.png)

이 아키텍처의 레이어는 동심원으로 서로 둘러싸여 있다. 이러한 아키텍처의 주요 규칙은 해당 계층 간의 모든 종속성이 내부를 가리켜야 한다는 종속성 규칙이다.

아키텍처의 핵심에는 주변 사용 사례에서 액세스하는 도메인 엔터티가 포함된다. 사용 사례는 이전에 서비스라고 불렀지만 단일 책임(즉, 변경해야 하는 단일 이유)을 갖도록 더 세분화되어 앞에서 논의한 광범위한 서비스의 문제를 방지한다.

이 코어 주변에서 비즈니스 규칙을 지원하는 애플리케이션의 다른 모든 구성 요소를 찾을 수 있다. 이러한 지원은 예를 들어 persistence를 제공하거나 UI를 제공하는 것을 의미할 수 있습니다. 또한 외부 레이어는 다른 타사 구성 요소에 대한 어댑터를 제공할 수 있다.

**도메인 코드는 어떤 persistence 또는 UI 프레임워크가 사용되는지에 대해 아무것도 모르기 때문에 해당 프레임워크에 특정한 코드를 포함할 수 없으며 비즈니스 규칙에 집중한다.** 도메인 코드를 모델링할 수 있는 자유가 있다. 예를 들어, DDD(Domain-Driven Design)를 가장 순수한 형태로 적용할 수 있다. 지속성 또는 UI 관련 문제에 대해 생각할 필요가 없기 때문에 훨씬 쉽다.

**예상할 수 있듯이 Clean 아키텍처에는 비용이 따른다.** 도메인 레이어는 지속성 및 UI와 같은 외부 레이어와 완전히 분리되어 있으므로 **각 레이어에서 애플리케이션 엔터티의 모델을 유지해야 한다.**

예를 들어, 지속성 계층에서 객체 관계형 매핑(ORM) 프레임워크를 사용한다고 가정해 보자. ORM 프레임워크는 일반적으로 데이터베이스 구조 및 데이터베이스 열에 대한 개체 필드 매핑을 설명하는 메타데이터가 포함된 특정 엔터티 클래스를 이야기한다. 도메인 계층은 persistence 계층을 모르기 때문에 도메인 계층에서 동일한 엔티티 클래스를 사용할 수 없으며 두 계층에서 모두 생성해야 한다. 즉, **도메인 계층이 persistence 계층과 데이터를 주고받을 때 두 표현 사이를 변환해야 한다.** 도메인 레이어와 다른 외부 레이어 간에 동일한 변환이 적용됩니다.

이 분리는 프레임워크 특정 문제에서 도메인 코드를 자유롭게 하기 위해 정확히 달성하고자 하는 것이다. 예를 들어, Java Persistence API(자바 세계의 표준 ORM-API)는 ORM 관리 엔터티가 도메인 모델에서 사용하지 않을 수 있는 기본 생성자를 가져야 한다. 8장, 경계 간의 매핑에서 우리는 도메인과 지속성 레이어 간의 결합을 수용하는 "노매핑" 전략을 포함하여 다양한 매핑 전략에 대해 이야기할 것이다.

로버트 C. 마틴의 클린 아키텍처는 다소 추상적이기 때문에 좀 더 세부적인 수준으로 가서 클린 아키텍처 원칙을 보다 구체적인 형태로 제공하는 "육각형 아키텍처"를 살펴보겠습니다.

### Hexagonal Architecture

![image-20210812054850651](./img/09.png)

육각형 아키텍처는 애플리케이션 코어가 각 어댑터와 상호 작용할 수 있는 특정 포트를 제공하기 때문에 "포트 앤 어댑터" 아키텍처라고도 한다.

애플리케이션 코어는 육각형으로 표시되어 이 아키텍처 스타일에 이름을 부여한다. 그러나 육각형 모양은 의미가 없으므로 팔각형을 그려서 "팔각형 아키텍처"라고 부를 수도 있다. 전설에 따르면 응용 프로그램이 다른 시스템이나 어댑터에 연결하는 4개 이상의 면이 있을 수 있음을 보여주기 위해 일반적인 직사각형 대신 육각형이 사용되었다고 한다.

육각형 내에서 도메인 엔티티와 함께 사용할 수 있는 사용 사례를 찾을 수 있다. 육각형에는 나가는 종속성이 없으므로 Martin의 클린 아키텍처의 종속성 규칙은 참으로 유지된다. 대신 모든 종속성이 중앙을 가리킨다.

육각형 외부에서 애플리케이션과 상호 작용하는 다양한 어댑터를 찾을 수 있다. 웹 브라우저와 상호 작용하는 웹 어댑터, 외부 시스템과 상호 작용하는 일부 어댑터 및 데이터베이스와 상호 작용하는 어댑터가 있을 수 있다.

왼쪽 어댑터는 애플리케이션을 구동하는 어댑터(애플리케이션 코어를 호출하므로)이고 오른쪽에 있는 어댑터는 애플리케이션에 의해 구동된다(애플리케이션 코어에 의해 호출되기 때문에).

애플리케이션 코어와 어댑터 간의 통신을 허용하기 위해 애플리케이션 코어는 특정 포트를 제공한다.  
애플리케이션 코어를 호출하는(구동하는) 어댑터의 경우 이러한 포트는 코어의 사용 사례 클래스 중 하나에 의해 구현되고 어댑터에 의해 호출되는 인터페이스일 수 있다.  
구동되는 어댑터의 경우 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스일 수 있다.

핵심 개념으로 인해 이 아키텍처 스타일은 "포트 앤 어댑터" 아키텍처라고도 한다. Clean 아키텍처와 마찬가지로 이 육각형 아키텍처를 레이어로 구성할 수 있다. 가장 바깥쪽 계층은 응용 프로그램과 다른 시스템 간에 변환하는 어댑터로 구성된다. 다음으로 포트와 사용 사례 구현을 결합하여 애플리케이션의 인터페이스를 정의하기 때문에 애플리케이션 계층을 형성할 수 있다. 마지막 레이어에는 도메인 엔터티가 포함된다.

다음 장에서는 이러한 아키텍처를 코드로 구성하는 방법에 대해 논의할 것이다.

### How Does This Help Me Build Maintainable Software?

클린 아키텍처, 6각형 아키텍처 또는 포트 및 어댑터 아키텍처라고 부르자. 도메인 코드가 외부에 종속되지 않도록 종속성을 반전함으로써 모든 지속성 및 UI 관련 문제에서 도메인 로직을 분리할 수 있다. 코드베이스 전체에서 변경해야 하는 이유의 수, 변경해야 할 이유가 적다는 것은 유지 관리가 용이하다는 것을 의미한다.

도메인 코드는 비즈니스 문제에 가장 적합하도록 자유롭게 모델링할 수 있는 반면 persistence 및 UI 코드는 persistence 및 UI 문제에 가장 적합하도록 자유롭게 모델링할 수 있다.

이 책의 나머지 부분에서는 육각형 아키텍처 스타일을 웹 애플리케이션에 적용할 것이다. 먼저 애플리케이션의 패키지 구조를 만들고 종속성 주입의 역할에 대해 논의한다.

