# Get Your Hands Dirty on Clean Architecture

> https://learning.oreilly.com/library/view/get-your-hands/9781839211966/
>
> 스터디
>
> 2021.08.11

## Chapter 3 - Organizing Code

코드만 봐도 아키텍처를 알 수 있다면 좋지 않을까?

이 장에서는 코드를 구성하는 다양한 방법을 살펴보고 육각형 아키텍처를 직접 반영하는 표현적인 패키지 구조를 알아본다.

미개발 소프트웨어 프로젝트에서 우리가 가장 먼저 제대로 하려고 하는 것이 패키지 구조이다. 우리는 프로젝트의 나머지 부분에 사용할 멋진 패키지 구조를 설계한다. 그러다 프로젝트 진행 중에 정신이 없어지고 많은 곳에서 패키지 구조가 구조화되지 않은 코드 난장판을 위한 외관일 뿐이라는 것을 깨닫게 된다. 한 패키지의 클래스는 가져와서는 안 되는 다른 패키지에서 클래스를 가져온다.

예제 응용프로그램의 코드를 구성하기 위한 다양한 옵션에 대해 논의할 것이다. 좀 더 구체적으로, 사용자가 자신의 계좌에서 다른 계좌로 송금할 수 있는 "송금" 사용 사례를 살펴보자.

### Organizing by Layer

코드를 구성하는 첫 번째 접근 방식은 계층을 사용하는 것이다. 다음과 같이 코드를 구성할 수 있다.

![image-20210812062122318](./img/10.png)

계층별로 코드를 구성할 때 기능적 측면이 혼합되는 경향이 있다.  

각 계층, 웹, 도메인 및 persistence에 대해 전용 패키지가 있다.  
1장, What's Wrong With Layers?에서 논의한 바와 같이, 간단한 계층은 여러 가지 이유로 인해 코드에 가장 적합한 구조가 아닐 수 있으므로, 여기서는 이미 종속성 반전 원칙을 적용했으며, 도메인 패키지의 도메인 코드에 대한 종속성만 허용한다.  
이를 위해 도메인 패키지에 AccountRepository 인터페이스를 도입하고 persistence 패키지에 구현했다.

그러나 이 패키지 구조가 차선책인 이유를 적어도 세 가지 찾을 수 있다.

**첫째, 애플리케이션의 기능적 단위나 기능 사이에 패키지 경계가 없다.**  
사용자 관리 기능을 추가하면 웹 패키지에 UserController를 추가하고 도메인 패키지에 UserService, UserRepository 및 User를 추가하고 지속성 패키지에 UserRepositoryImpl을 추가한다.  
추가 구조가 없으면 이는 빠르게 클래스를 엉망으로 만들어 응용 프로그램의 관련되지 않은 기능 간에 원치 않는 부작용을 초래할 수 있습니다.

**둘째, 애플리케이션이 제공하는 Use Case를 볼 수 없다.** AccountService 또는 AccountController 클래스가 구현하는Use Case를 알 수 있을까? 특정 기능을 찾고 있다면 어떤 서비스가 그것을 구현하는지 추측한 다음 해당 서비스 내에서 책임 있는 메소드를 검색해야 한다.

**마찬가지로 패키지 구조 내에서 대상 아키텍처를 볼 수 없다.**  
6각형 아키텍처 스타일을 따랐다고 추측할 수 있으며 웹 및 persistence 패키지의 클래스를 탐색하여 웹 및 persistence 어댑터를 찾을 수 있다.  
그러나 웹 어댑터가 호출하는 기능과 persistence 어댑터가 도메인 계층에 제공하는 기능을 한 눈에 볼 수 없습니다. **들어오는 포트와 나가는 포트는 코드에 숨겨져 있습니다.**

### Organizing by Feature

"계층별 구성" 접근 방식의 몇 가지 문제를 해결해 보자

다음 접근 방식은 코드를 기능별로 구성하는 것이다.

![image-20210812062918560](./img/11.png)

기능별로 코드를 구성할 때 기본 아키텍처가 명확하지 않은 경향이 있다.  
본질적으로 계정과 관련된 모든 코드를 상위 수준 계정 패키지에 넣었다. 레이어 패키지도 제거했다.

각각의 새로운 기능 그룹은 계정 옆에 새로운 상위 수준 패키지를 갖게 되며 외부에서 액세스해서는 안 되는 클래스에 대한 package-private 가시성을 사용하여 기능 간에 패키지 경계를 적용할 수 있다.

package-private 가시성과 결합된 패키지 경계를 통해 기능 간의 원치 않는 종속성을 피할 수 있다.

또한 책임을 줄이기 위해 AccountService의 이름을 SendMoneyService로 변경했습니다(패키지별 접근 방식에서도 가능).  
이제 클래스 이름만 봐도 "Send Money" Use Case를 코드가 구현함을 알 수 있습니다.  
응용프로그램의 기능을 코드에 표시하는 것은 Robert Martin이 "screaming architecture"라고 부르는 것인데, 이는 응용프로그램이 우리에게 의도를 전달하기 때문입니다(Robert C의 Clean Architecture). 마틴, 프렌티스 홀, 2017, 21장).

그러나 package-by-feature 접근 방식은 아키텍처를 훨씬 덜 가시적으로 만든다.  

어댑터를 식별할 수 있는 패키지 이름이 없으며 여전히 수신 및 발신 포트가 표시되지 않는다.  
게다가 SendMoneyService가 AccountRepository 인터페이스만 알고 구현은 알 수 없도록 도메인 코드와 지속성 코드 간의 종속성을 역전시켰지만 package-private 가시성을 사용하여 도메인 코드를 실수로 인한 종속성으로부터 persistence 코드로 보호할 수는 없습니다.

### An Architecturally Expressive Package Structure

육각형 아키텍처에는 엔터티, Use Case, 수신 및 발신 포트, 수신 및 발신(또는 "driving" 및 "driven") 어댑터가 주요 아키텍처 요소로 있습니다. 이 요소들을 아키텍처를 표현하는 패키지 구조에 맞춰보자.

아키텍처 표현이 풍부한 패키지 구조에서 각 아키텍처 요소는 제 위치를 가진다.



![image-20210812064016969](./img/12.png)

아키텍처의 각 요소는 패키지 중 하나에 직접 매핑될 수 있다.  
최상위 수준에서 다시 **account라는 패키지**가 있는데, 이는 이것이 계정에 대한 Use Case를 구현하는 모듈임을 나타낸다.

다음 레벨에는 도메인 모델이 포함된 domain 패키지가 있다.  

**application 패키지**에는 이 도메인 모델에 대한 서비스 계층이 포함되어 있다.  
SendMoneyService는 input 포트 인터페이스인 SendMoneyUseCase를 구현하고. 
persistence 어댑터에 의해 구현되는 output 포트 인터페이스인 LoadAccountPort 및 UpdateAccountStatePort를 사용한다.

**adapter 패키지**에는 응용 프로그램 계층의 input 포트를 호출하는 input 어댑터와 응용 프로그램 계층의 output 포트에 대한 구현을 제공하는 output 어댑터가 포함되어 있다.  
우리의 경우에는 각각 고유한 하위 패키지가 있는 웹 및 persistence 어댑터를 사용하여 간단한 웹 애플리케이션을 구축하고 있다.

사무실 벽에 걸린 육각형 아키텍처에 대한 높은 수준의 뷰를 가지고 있으며, 사용 중인 타사 API로 클라이언트를 수정하는 것에 대해 동료와 이야기를 나누고 있다고 상상해 보자.  
이에 대해 논의하는 동안 아키텍처에 있는 해당 out 어댑터를 가리키면 서로를 더 잘 이해할 수 있다.  
그런 다음 이야기를 마치면 IDE 앞에 앉아 바로 클라이언트에 대한 작업을 시작할 수 있다. 앞서 언급한 API 클라이언트의 코드는 adapter/out/<어댑터 이름> 패키지에서 찾을 수 있기 때문이다.

이러한 패키지 구조는 소위 "아키텍처-코드 격차" 또는 "모델-코드 격차"에 대항하는 강력한 요소이다.(Just Enough Architecture by George Fairbanks, Marshall & Brainerd, 2010, 167페이지).  
이 용어들은 대부분의 소프트웨어 개발 프로젝트에서 아키텍처가 코드에 직접 매핑될 수 없는 추상적 개념에 불과하다는 사실을 설명한다.  
시간이 지남에 따라 패키지 구조가 아키텍처를 반영하지 않으면 코드는 일반적으로 대상 아키텍처에서 점점 더 벗어날 것입니다.

패키지가 너무 많다는 것은 패키지 간에 액세스를 허용하기 위해 모든 것이 공개되어야 한다는 것을 의미하지 않는가?

**adapter 패키지의 경우** 적어도 이것은 사실이 아닙니다. 포함된 모든 클래스는 애플리케이션 패키지 내에 있는 포트 인터페이스를 제외하고 외부 세계에서 호출되지 않기 때문에 **package-private일 수 있습니다.** 따라서 응용 프로그램 계층에서 어댑터 클래스로의 우발적인 종속성이 없습니다.

그러나 **application 및 domain 패키지 내에서 일부 클래스는 실제로 공개되어야 한다.**  
포트는 설계상 어댑터에서 액세스할 수 있어야 하므로 public 포트여야 한다.  
도메인 클래스는 public 상태여야 서비스 및 어댑터가 액세스할 수 있다.  
서비스는 수신 포트 인터페이스 뒤에 숨겨질 수 있으므로 공용일 필요가 없다.

adapter 코드를 자체 패키지로 이동하면 필요할 경우 한 어댑터를 다른 구현으로 매우 쉽게 교체할 수 있다는 추가 이점이 있다.  
간단한 키-값 데이터베이스에 대해 구현을 시작했다고 상상해 보자.  
결국 어떤 데이터베이스가 가장 좋을지 확신하지 못했기 때문에 이제 SQL 데이터베이스로 전환해야 한다.  
새로운 어댑터 패키지에 관련된 모든 out 포트를 구현한 다음 이전 패키지를 제거하기만 하면 된다.

이 패키지 구조의 또 다른 매우 매력적인 장점은 DDD 개념에 직접 매핑된다는 것이다.  
이 경우 상위 패키지인 account는 다른 경계 컨텍스트와 통신하기 위한 전용 진입점 및 출구 지점(포트)이 있는 경계 컨텍스트이다.  
도메인 패키지 내에서 DDD가 제공하는 모든 도구를 사용하여 원하는 도메인 모델을 구축할 수 있다.

모든 구조와 마찬가지로 소프트웨어 프로젝트의 수명 동안 이 패키지 구조를 유지하려면 규칙이 필요하다.  
또한 패키지 구조가 맞지 않아 아키텍처/코드 간극을 넓히고, 아키텍처를 반영하지 않는 패키지를 만드는 것 외에 다른 방법이 보이지 않는 경우가 있다.

완벽이란 없다. 그러나 표현적인 패키지 구조를 사용하면 최소한 코드와 아키텍처 사이의 간격을 줄일 수 있다.

### The Role of Dependency Injection

앞에서 설명한 패키지 구조는 Clean 아키텍처로 발전하지만,  
이러한 아키텍처의 필수적인 요구사항은 애플리케이션 계층이 2장 "*Inverting Dependencies*."에서 배운 바와 같이 들어오고 나가는 어댑터에 종속성을 갖지 않는 것이다.

웹 어댑터와 같은 수신 어댑터의 경우 제어 흐름이 어댑터와 도메인 코드 간의 의존성과 동일한 방향을 가리키기 때문에 이 작업이 쉽다.  
어댑터는 단순히 애플리케이션 계층 내에서 서비스를 호출한다.  
애플리케이션에 대한 진입점을 명확하게 구분하기 위해 그럼에도 불구하고 포트 인터페이스 간에 실제 서비스를 숨기고 싶을 수 있다.

persistence 어댑터와 같은 나가는 어댑터의 경우 의존성 역전 원칙을 사용하여 종속성을 제어 흐름의 방향으로 전환해야 한다.

우리는 이미 그것이 어떻게 작동하는지 봤다.  
adapter 내의 클래스에서 구현하는 인터페이스를 애플리케이션 계층 내에 만든다.   
육각형 아키텍처 내에서 이 인터페이스는 port입니다.  
그런 다음 애플리케이션 계층은 이 포트 인터페이스를 호출하여 다음 그림과 같이 어댑터의 기능을 호출한다.

![image-20210812071206623](./img/13.png)

웹 컨트롤러는 서비스에 의해 구현되는 수신 포트를 호출한다.  
서비스는 어댑터에 의해 구현되는 나가는 포트를 호출한다.

그러나 포트 인터페이스를 구현하는 실제 객체를 응용 프로그램에 제공자는 누구일까?  
adapter에 의존성을 도입하고 싶지 않기 때문에 애플리케이션 계층 내에서 포트를 수동으로 인스턴스화하고 싶지 않다.

여기서 의존성 주입이 작동한다.  
모든 레이어에 의존하는 중립적인 컴포넌트를 소개한다.  
이 구성 요소는 아키텍처를 구성하는 대부분의 클래스를 인스턴스화하는 역할을 한다.

앞의 예제 그림에서 중립 의존성 주입 구성 요소는 AccountController, SendMoneyService 및 AccountPersistenceAdapter 클래스의 인스턴스를 생성한다.  
AccountController에는 SendMoneyUseCase 인터페이스가 필요하기 때문에 의존성 주입은 생성 중에 SendMoneyService 클래스의 인스턴스를 제공한다.  
컨트롤러는 인터페이스만 알면 되기 때문에 실제로 SendMoneyService 인스턴스가 있다는 것을 알지 못한다.

마찬가지로 SendMoneyService 인스턴스를 구성할 때 의존성 주입 메커니즘은 LoadAccountPort 인터페이스의 모습으로 AccountPersistenceAdapter 클래스의 인스턴스를 주입한다.  
서비스는 인터페이스 뒤에 있는 실제 클래스를 절대 알지 못한다.

### How Does This Help Me Build Maintainable Software?

실제 코드 구조를 대상 아키텍처에 최대한 가깝게 취하는 6각형 아키텍처용 패키지 구조를 살펴봤다.  
코드에서 아키텍처의 요소를 찾는 것은 이제 아키텍처 다이어그램에서 특정 package의 이름과 함께 package 구조를 탐색하는 문제로 communication, 개발 및 유지 보수에 도움이 된다.

